workflow:
  name: Solar System NodeJS Pipeline
  rules:
    # Run on pushes to main or feature branches
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH =~ /^feature/
      when: always
    # Run on merge request events from feature branches
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/ && $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always

variables:
  DOCKER_USERNAME: revel72
  IMAGE_VERSION: $CI_PIPELINE_ID
  K8S_IMAGE: $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
  MONGO_URI: 'mongodb+srv://supercluster.d83jj.mongodb.net/superData'
  MONGO_USERNAME: superuser
  MONGO_PASSWORD: $M_DB_PASSWORD

stages:
  - test
  - containerization
  - dev-deploy
  - stage-deploy

.default_cache: &default_cache
  key:
    files:
      - package-lock.json
    prefix: node_modules
  paths:
    - node_modules
  policy: pull-push
  when: on_success

.unit_testing:
  stage: test
  image: node:17-alpine3.14
  services:
    - name: siddharth67/mongo-db:non-prod
      alias: mongo
      pull_policy: always
  variables:
    MONGO_URI: 'mongodb://mongo:27017/superData'
    MONGO_USERNAME: non-prod-user
    MONGO_PASSWORD: $M_DB_PASSWORD
  cache: *default_cache
  before_script:
    - npm install
  script:
    - npm test
  artifacts:
    when: always
    expire_in: 3 days
    name: "Mocha-Test-Result"
    paths:
      - test-results.xml
    reports:
        junit: test-results.xml

.code_coverage:
  stage: test
  image: node:17-alpine3.14
  services:
    - name: siddharth67/mongo-db:non-prod
      alias: mongo
      pull_policy: always
  variables:
    MONGO_URI: 'mongodb://mongo:27017/superData'
    MONGO_USERNAME: non-prod-user
    MONGO_PASSWORD: $M_DB_PASSWORD
  cache: *default_cache
  before_script:
    - npm install
  script:
    - npm run coverage
  artifacts:
    name: Code-Coverage-Result
    when: always
    expire_in: 3 days
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  allow_failure: true

.docker_build:
  stage: containerization
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  dependencies: []
  script:
    - docker build -t $DOCKER_USERNAME/solar-system:$IMAGE_VERSION .
    - docker images $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
    - mkdir image
    - docker save $DOCKER_USERNAME/solar-system:$IMAGE_VERSION > image/solar-system-image-$IMAGE_VERSION.tar
  artifacts:
    when: on_success
    expire_in: 3 days
    paths:
      - image

.docker_test:
  stage: containerization
  image: docker:24.0.5
  needs:
    - docker_build
  services:
    - docker:24.0.5-dind
  script:
    - docker load -i image/solar-system-image-$IMAGE_VERSION.tar
    - docker run --name solar-system-app -d -p 3000:3000 $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
    - export IP=$(docker inspect -f \
        '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' solar-system-app)
    - echo $IP
    - docker run --rm alpine sh -c "apk add --no-cache wget >/dev/null && wget -qO- http://$IP:3000/live | grep -q '\"live\"'"

.docker_push:
  stage: containerization
  image: docker:24.0.5
  needs:
    - docker_build
    - docker_test
  services:
    - docker:24.0.5-dind
  script:
    - docker load -i image/solar-system-image-$IMAGE_VERSION.tar
    - docker login --username=$DOCKER_USERNAME --password=$DOCKER_PASSWORD
    - docker push $DOCKER_USERNAME/solar-system:$IMAGE_VERSION

.publish_gitlab_container_registry:
  stage: containerization
  needs:
    - docker_build
    - docker_test
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  script:
    - docker load -i image/solar-system-image-$CI_PIPELINE_ID.tar
    - echo "$CI_REGISTRY | $CI_REGISTRY_USER | $CI_REGISTRY_IMAGE"
    - docker login $CI_REGISTRY -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD"
    - docker tag $DOCKER_USERNAME/solar-system:$IMAGE_VERSION $CI_REGISTRY_IMAGE/ss-image:$IMAGE_VERSION
    - docker images
    - docker push $CI_REGISTRY_IMAGE/ss-image:$IMAGE_VERSION

.k8s_dev_deploy:
  stage: dev-deploy
  dependencies: []
  environment: 
    name: development
    url: $INGRESS_URL
  tags:
    - dev
  script:
    - export KUBECONFIG=$DEV_KUBE_CONFIG
    - kubectl version -o yaml
    - kubectl config get-contexts
    - kubectl get nodes
    - export NAMESPACE=development
    - export INGRESS_IP=$(kubectl get node -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
    - echo "ðŸ“¡ INGRESS_IP resolved $INGRESS_IP"
    - |
      if [ -z "$INGRESS_IP" ]; then
        echo "âŒ INGRESS_IP is empty. Invalid ingress host would be generated."
        exit 1
      fi
    - export INGRESS_URL="solar-system-development.${INGRESS_IP}.nip.io"
    - echo "$INGRESS_URL" > ingress_url.txt
    - kubectl -n $NAMESPACE create secret generic mongo-db-creds --from-literal=MONGO_URI="$MONGO_URI" --from-literal=MONGO_USERNAME="$MONGO_USERNAME" --from-literal=MONGO_PASSWORD="$MONGO_PASSWORD" --dry-run=client -o yaml | kubectl apply -f -
    - kubectl get namespace development || kubectl create namespace development
    - |
      for file in kubernetes/development/*.yaml; do
        echo "Processing $file"
        envsubst < "$file" | kubectl apply -f -
      done
    - kubectl -n $NAMESPACE get all,secret,ingress
  artifacts:
    paths:
      - ingress_url.txt

.k8s_dev_integration_testing:
  stage: dev-deploy
  needs:
    - job: k8s_dev_deploy
      artifacts: true
  image: alpine:3.7
  before_script:
    - apk --no-cache add curl jq
    - export INGRESS_URL=$(cat ingress_url.txt)
  script:
    - echo "Using Ingress URL $INGRESS_URL"

k8s_stage_deploy:
  stage: stage-deploy
  image: alpine:3.7
  when: manual
  before_script:
    - wget https://storage.googleapis.com/kubernetes-release/release/$(wget -q -O - https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
    - chmod +x ./kubectl && mv ./kubectl /usr/bin/kubectl
    - apk add --no-cache gettext && envsubst -V
  script:
    # Inspect and switch the Agent context
    - cat $KUBECONFIG
    - kubectl config get-contexts
    - kubectl config use-context louisgimeno72/solar-system:kk-gitlab-agent
    - kubectl get po -A
    # Deploy application
    - export INGRESS_IP=$(kubectl get node -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
    - echo "ðŸ“¡ INGRESS_IP resolved $INGRESS_IP"
    - |
      if [ -z "$INGRESS_IP" ]; then
        echo "âŒ INGRESS_IP is empty. Invalid ingress host would be generated."
        exit 1
      fi
    - export INGRESS_URL="solar-system-development.${INGRESS_IP}.nip.io"
    - echo "$INGRESS_URL" > ingress_url.txt
    - kubectl -n $NAMESPACE create secret generic mongo-db-creds --from-literal=MONGO_URI="$MONGO_URI" --from-literal=MONGO_USERNAME="$MONGO_USERNAME" --from-literal=MONGO_PASSWORD="$MONGO_PASSWORD" --save-config --dry-run=client -o yaml | kubectl apply -f -
    - |
      for file in kubernetes/development/*.yaml; do
        echo "Processing $file"
        envsubst < "$file" | kubectl apply -f -
      done
    - kubectl -n $NAMESPACE get all,secret,ingress
  artifacts:
    paths:
      - ingress_url.txt
  environment:
    name: staging
    url: https://${INGRESS_URL}

k8s_stage_integration_testing:
  stage: stage-deploy
  image: alpine:3.7
  needs:
    - job: k8s_stage_deploy
      artifacts: true
  before_script:
    - apk add --no-cache curl jq
    - export INGRESS_URL=$(cat ingress_url.txt)
  script:
    - echo "Testing URL $INGRESS_URL"